[%# A template for a service implementation code
      (an empty implementation of a service)
    ============================================

    Expected/recognized parameters:

      base         ... a service base definition
                       (type MOSES::MOBY::Def::Service)
      impl         ... a service implementation details
                       (type HASH)
      static_impl  ... if true, the static option will be enabled
      get_children ... a CODE returning all children datatypes of a given one:
                       [MOSES::MOBY::Def::Relationship] <= get_childern (datatype_name)
      ref          ... a CODE returning ref() of the given argument
      input_paths  ... an array of structures, each of them for one input,
                       defining all children of an input, considering differently
                       HAS and HASA children. For example, for one input (part of
                       a real data type 'BasicGFFSequenceFeature'):
      $paths = {
	score = [ 'gff', 'score', 'value' ],
	reference = [ 'gff', 'reference', 'value' ],
	column9_tag_value = [ 'gff', 'column9_tag_value' ,
			       { key = [ 'column9_tag_value_element', 'key', 'value' ],
				 value = [ 'column9_tag_value_element', 'value',
					    { value = [ 'value_element', 'value' ], } ], }, ],
        }
-%]      
    [%- MACRO is_simple (entry) BLOCK %]
	[%- ref (entry) == 'MOSES::MOBY::Def::PrimaryDataSimple' %]
    [%- END -%]

    [%- MACRO set_child (child, leftpad, value) BLOCK %]
       [% FILTER indent (leftpad) -%]
       [%- child.memberName %] => [% set_value (child, leftpad, value) %]
       [%- END %]
    [%- END -%]

    [%- MACRO set_value (child, leftpad, value) BLOCK %]
       [%- IF child.datatype    == 'String'   %]"this is a '[% child.memberName %] [% value %]'",   # TO BE EDITED
       [%- ELSIF child.datatype == 'Integer'  %]42,   # TO BE EDITED
       [%- ELSIF child.datatype == 'Float'    %]0.42, # TO BE EDITED
       [%- ELSIF child.datatype == 'Boolean'  %]1,    # TO BE EDITED
       [%- ELSIF child.datatype == 'DateTime' %]'1982-12-31T16:20:00Z+0000',   # TO BE EDITED
       [%- ELSE %]new [% child.module_datatype %]
       (
       [%- FOREACH child IN get_children (child.datatype) %]
       [%- new_leftpad = leftpad + 4 %]
       [%- set_child (child, new_leftpad, value) %]
       [%- END %]
       ),
       [%- END %]
    [%- END -%]

    [%- MACRO no_children (datatype, value) BLOCK %]
       [%- IF datatype    == 'String'   %]value => "this is a value [% value %]",   # TO BE EDITED
       [%- ELSIF datatype == 'Integer'  %]value => 42,   # TO BE EDITED
       [%- ELSIF datatype == 'Float'    %]value => 0.42, # TO BE EDITED
       [%- ELSIF datatype == 'Boolean'  %]value => 1,    # TO BE EDITED
       [%- ELSIF datatype == 'DateTime' %]value => '1982-12-31T16:20:00Z+0000',   # TO BE EDITED
       [%- ELSE %]id => '12345'
       [%- END %]
    [%- END -%]

    [%- global.id = 1 -%]
    [%- MACRO unique (name) BLOCK %]
       [%- unique_name = name %]
       [%- FOREACH input IN base.inputs %]
          [%- IF input.name == name %]
             [%- global.id = global.id + 1 %]
             [%- unique_name = "${name}_${global.id}" %]
             [%- LAST %]
          [%- END %]
       [%- END %]
       [%- unique_name %]
    [%- END -%]

    [%- MACRO get_members (paths, leftpad, in_loop) BLOCK -%]
      [%- FILTER indent (leftpad) %]
        [%- FOREACH member IN paths.keys %]
my $[% member %] = eval { $
          [%- FOREACH part IN paths.$member %]
            [%- IF ref (part) == 'HASH' %] };
if (defined $[% member %]) {
              [%- new_leftpad = leftpad + 4 %]
    foreach my $[% member %]_element (@{ $[% member %] }) {
                [%- get_members (part, new_leftpad, 1) %]
    }
}
              [%- NEXT %]
            [%- ELSE %]
              [%- IF NOT loop.first %]->[% END %][% part %]
              [%- IF loop.last %] };
                 [%- IF in_loop == 1 %]
# do something with $[% member %] (if defined)
# ...
                 [%- END %]
              [%- END %]
            [%- END %]
          [%- END %]
        [%- END %]
      [%- END %]
    [%- END -%]

#-----------------------------------------------------------------
# Service name: [% base.name %]
# Authority:    [% base.authority %]
# Created:      [% USE Date (format = '%d-%b-%Y %H:%M:%S %Z') %][% Date.format %]
# Contact:      [% base.email %]
# Description:  [% USE description = String (base.description) %]
                [%- description.replace("\n", "\n#\t") %]
#-----------------------------------------------------------------

package [% impl.package %];

use FindBin qw( $Bin );
use lib $Bin;

#-----------------------------------------------------------------
# This is a mandatory section - but you can still choose one of
# the two options (keep one and commented out the other):
#-----------------------------------------------------------------
use MOSES::MOBY::Base;
[%- IF static_impl == 1 %][% opt1 = '#'; opt2 = '' %][% ELSE %][% opt1 = ''; opt2 = '#' %][% END %]
# --- (1) this option loads dynamically everything
[% opt1 %]BEGIN {
[% opt1 %]    use MOSES::MOBY::Generators::GenServices;
[% opt1 %]    new MOSES::MOBY::Generators::GenServices->load
[% opt1 %]	(authority     => '[% base.authority %]',
[% opt1 %]	 service_names => ['[% base.name %]']);
[% opt1 %]}

# --- (2) this option uses pre-generated module
#  You can generate the module by calling a script:
#    moses-generate-services -b [% base.authority %] [% base.name %]
#  then comment out the whole option above, and uncomment
#  the following line (and make sure that Perl can find it):
[% opt2 %]use [% base.module_name %];

# (this to stay here with any of the options above)
use vars qw( @ISA );
@ISA = qw( [% base.module_name %] );
use MOSES::MOBY::Package;
use MOSES::MOBY::ServiceException;
use strict;

my %valid_namespaces = ( [% FOREACH ns IN input_ns %] '[%ns%]'=>1,  [% END %]);
#-----------------------------------------------------------------
# process_it
#    This method is called for every job in the client request.
#    Input data are in $request, this method creates a response
#    into $response. The $context tells about all other jobs
#    from the same request, and it can be used to fill there
#    exceptions and service notes.
#-----------------------------------------------------------------
sub process_it {
    my ($self, $request, $response, $context) = @_;

    # read input data (eval to protect against missing data)
    
    # NOTE: the following variables are for your information only
    # please make sure to rename any of the variables that you use
    # to ensure that variable shadowing doesnt become an issue!
	
	[%- FOREACH input IN base.inputs %]
    [%- IF input.name.match ('^MISSING_ARTICLE_NAME') %]
    my $[% input.name %][% IF NOT is_simple (input) %]_collection [% END %] = eval { $request->getData->data };
    [%- ELSE %]
    my $[% input.name %][% IF NOT is_simple (input) %]_collection [% END %] = eval { $request->[% input.name %] };
    [%- END %]
	
    [%- IF is_simple (input) %]
[% get_members (input_paths.${input.name}, 4) %]
    # perform namespace checking for inputs to this service
#   do {
#       $response->record_error ( { code => INPUT_INCORRECT_NAMESPACE,
#                                   msg  => 'This service requires inputs under the namespaces: {"' . join(',', keys %valid_namespaces) . '"}' } );
#       return;
#   } unless $valid_namespaces{$namespace};
    [%- ELSE %]
    if (defined $[% input.name %]_collection) {
        foreach my $[% input.name %]_element (@{ $[% input.name %]_collection }) {
            my $[% input.name %] = $[% input.name %]_element->data;
[% get_members (input_paths.${input.name}, 12) %]
            # perform namespace checking for inputs to this service
        #   do {
        #       $response->record_error ( { code => INPUT_INCORRECT_NAMESPACE,
        #                                   msg  => 'This service requires inputs under the namespaces: { "' . join(',', keys %valid_namespaces) . '"}' } );
        #       return;
        #   } unless $valid_namespaces{$namespace};
        }
    }
    [%- END %]
    [%- END %]

    [%- IF base.secondarys.size > 0 %]
    # read parameters (eval to protect against missing ones)
    [%- FOREACH param IN base.secondarys %]
    my $[% param.name %] = eval { $request->getParameter ('[% param.name %]') };
    [%- END %]
    [%- END %]

    # CONSIDER TO REMOVE THIS LATER - it's filling the logfile
    # this will log input data:
    [%- FOREACH input IN base.inputs %]
    [%- IF is_simple(input) %]
    $LOG->info ("Input data ([% input.name %]):\n" . $[% input.name %])
        if defined $[% input.name %];
    [%- ELSE %]
    $LOG->info ("Input data ([% input.name %], a collection):\n" . join ("\n", @{ $[% input.name %]_collection }) )
        if defined $[% input.name %]_collection;
    [%- END %]
    [%- END %]

    # do something... (sorry, can't help with that)

    # EDIT: PUT REAL VALUES INTO THE RESPONSE
    # fill the response
    [%- FOREACH output IN base.outputs %]
    [%- IF is_simple(output) %]
    [%- unique_output_name = unique (output.name) %]
    my $[% unique_output_name %] = new [% output.datatype.module_name %]
        (
         [%- children = get_children (output.datatype.name) %]
         [%- IF children.size == 0 %]
         [% no_children (output.datatype.name) %]
	 [%- ELSE %]
         [%- FOREACH child IN children %]
             [%- set_child (child, 2) %]
         [%- END %]
         [%- END %]
         );
    $response->[% output.name %] ($[% unique_output_name %]);
    [%- ELSE %]
    foreach my $elem (0..2) {
        my $[% output.name %] = new [% output.elements.0.datatype.module_name %]
            (
	     [%- children = get_children (output.elements.0.datatype.name) %]
	     [%- IF children.size == 0 %]
	     [% no_children (output.elements.0.datatype.name) %]
	     [%- ELSE %]
	     [%- FOREACH child IN children %]
                 [%- set_child (child, 6 '$elem') %]
             [%- END %]
             [%- END %]
             );
        $response->add_[% output.name %] ($[% output.name %]);
    }
    [%- END %]
    [%- END %]

    # fill service notes (if you wish)
    $context->serviceNotes
       ('Response created at ' . gmtime() . ' (GMT), by the service \'[% base.name %]\'.');

    # this is how to fill (record) exceptions
#    $response->record_info ('This is an info');
#    $response->record_warning ('This is a warning');
#    $response->record_error ('This is an error');
#    $response->record_error ( { code => INPUTS_INVALID,
# 				 msg  => 'This is an error with a code' } );

}

1;
__END__

=head1 NAME

[% impl.package %] - a BioMoby service

=head1 SYNOPSIS

=head1 DESCRIPTION

[% base.description %]

=head1 CONTACT

B<Authority>: [% base.authority %]

B<Email>: [% base.email %]

=cut
